/* tslint:disable */
/* eslint-disable */
export function seed_to_descriptor(seed: Uint8Array, network: Network, address_type: AddressType): DescriptorPair;
export function xpriv_to_descriptor(extended_privkey: string, fingerprint: string, network: Network, address_type: AddressType): DescriptorPair;
export function xpub_to_descriptor(extended_pubkey: string, fingerprint: string, network: Network, address_type: AddressType): DescriptorPair;
export function seed_to_xpriv(seed: Uint8Array, network: Network): string;
export function slip10_to_extended(slip10: any, network: Network): string;
/**
 * The different types of addresses.
 */
type AddressType = "p2pkh" | "p2sh" | "p2wpkh" | "p2wsh" | "p2tr";
/**
 * A set of denominations in which amounts can be expressed.
 */
type Denomination = "BTC" | "cBTC" | "mBTC" | "uBTC" | "nBTC" | "pBTC" | "bits" | "satoshi" | "msat";
/**
 * Types of keychains
 */
type KeychainKind = "external" | "internal";
/**
 * The cryptocurrency network to act on.
 */
type Network = "bitcoin" | "testnet" | "testnet4" | "signet" | "regtest";
/**
 * A Bitcoin address.
 */
export class Address {
  private constructor();
  free(): void;
  static from_string(address_str: string, network: Network): Address;
  /**
   * Constructs an [`Address`] from an output script (`scriptPubkey`).
   */
  static from_script(script_buf: ScriptBuf, network: Network): Address;
  toString(): string;
}
/**
 * A derived address and the index it was found at.
 */
export class AddressInfo {
  private constructor();
  free(): void;
  /**
   * Child index of this address
   */
  readonly index: number;
  /**
   * Address
   */
  readonly address: Address;
  /**
   * Type of keychain
   */
  readonly keychain: KeychainKind;
  /**
   * Gets the address type of the address.
   *
   * # Returns
   *
   * None if unknown, non-standard or related to the future witness version.
   */
  readonly address_type: AddressType | undefined;
}
/**
 * Amount
 *
 * The [Amount] type can be used to express Bitcoin amounts that support
 * arithmetic and conversion to various denominations.
 */
export class Amount {
  private constructor();
  free(): void;
  static from_btc(btc: number): Amount;
  static from_sat(satoshi: bigint): Amount;
  /**
   * Gets the number of satoshis in this [`Amount`].
   */
  to_sat(): bigint;
  /**
   * Express this [`Amount`] as a floating-point value in Bitcoin.
   *
   * Please be aware of the risk of using floating-point numbers.
   */
  to_btc(): number;
  /**
   * Express this [Amount] as a floating-point value in the given denomination.
   *
   * Please be aware of the risk of using floating-point numbers.
   */
  to_float_in(denom: Denomination): number;
}
/**
 * Balance, differentiated into various categories.
 */
export class Balance {
  private constructor();
  free(): void;
  /**
   * All coinbase outputs not yet matured
   */
  readonly immature: Amount;
  /**
   * Unconfirmed UTXOs generated by a wallet tx
   */
  readonly trusted_pending: Amount;
  /**
   * Unconfirmed UTXOs received from an external wallet
   */
  readonly untrusted_pending: Amount;
  /**
   * Confirmed and immediately spendable balance
   */
  readonly confirmed: Amount;
  /**
   * Get sum of trusted_pending and confirmed coins.
   *
   * This is the balance you can spend right now that shouldn't get cancelled via another party
   * double spending it.
   */
  readonly trusted_spendable: Amount;
  /**
   * Get the whole balance visible to the wallet.
   */
  readonly total: Amount;
}
/**
 * A reference to a block in the canonical chain.
 */
export class BlockId {
  private constructor();
  free(): void;
  /**
   * The height of the block.
   */
  readonly height: number;
  /**
   * The hash of the block.
   */
  readonly hash: string;
}
/**
 * Represents the observed position of some chain data.
 */
export class ChainPosition {
  private constructor();
  free(): void;
  /**
   * Returns whether [`ChainPosition`] is confirmed or not.
   */
  readonly is_confirmed: boolean;
  /**
   * Determines the upper bound of the confirmation height.
   */
  readonly confirmation_height_upper_bound: number | undefined;
  /**
   * When the chain data is last seen in the mempool.
   *
   * This value will be `None` if the chain data was never seen in the mempool and only seen
   * in a conflicting chain.
   */
  readonly last_seen: bigint | undefined;
  /**
   * The [`Anchor`].
   */
  readonly anchor: ConfirmationBlockTime | undefined;
  /**
   * Whether the chain data is anchored transitively by a child transaction.
   *
   * If the value is `Some`, it means we have incomplete data. We can only deduce that the
   * chain data is confirmed at a block equal to or lower than the block referenced by `A`.
   */
  readonly transitively: Txid | undefined;
}
/**
 * A changeset for [`Wallet`].
 */
export class ChangeSet {
  private constructor();
  free(): void;
  /**
   * Merge another [`ChangeSet`] into itself.
   */
  merge(other: ChangeSet): void;
  is_empty(): boolean;
  /**
   * Serialize `ChangeSet` to JSON.
   */
  to_json(): string;
  /**
   * Serialize `ChangeSet` to JSON compatible with WASM.
   */
  to_js(): any;
  /**
   * Create a new `ChangeSet` from a JSON string.
   */
  static from_json(val: string): ChangeSet;
  /**
   * Create a new `ChangeSet` from a JS object.
   */
  static from_js(js_value: any): ChangeSet;
}
/**
 * A checkpoint is a node of a reference-counted linked list of [`BlockId`]s.
 *
 * Checkpoints are cheaply cloneable and are useful to find the agreement point between two sparse
 * block chains.
 */
export class CheckPoint {
  private constructor();
  free(): void;
  /**
   * Get checkpoint at `height`.
   *
   * Returns `None` if checkpoint at `height` does not exist.
   */
  get(height: number): CheckPoint | undefined;
  /**
   * Get the [`BlockId`] of the checkpoint.
   */
  readonly block_id: BlockId;
  /**
   * Get the height of the checkpoint.
   */
  readonly height: number;
  /**
   * Get the block hash of the checkpoint.
   */
  readonly hash: string;
  /**
   * Get the previous checkpoint in the chain
   */
  readonly prev: CheckPoint | undefined;
}
/**
 * Represents the observed position of some chain data.
 */
export class ConfirmationBlockTime {
  private constructor();
  free(): void;
  /**
   * The anchor block.
   */
  readonly block_id: BlockId;
  /**
   * The confirmation time of the transaction being anchored.
   */
  readonly confirmation_time: bigint;
}
/**
 * Pair of descriptors for external and internal keychains
 */
export class DescriptorPair {
  free(): void;
  constructor(external: string, internal: string);
  readonly internal: string;
  readonly external: string;
}
/**
 * Map where the key is the confirmation target (in number of blocks) and the value is the estimated feerate (in sat/vB).
 */
export class FeeEstimates {
  private constructor();
  free(): void;
  /**
   * Returns the feerate (in sat/vB) or undefined.
   * Available confirmation targets are 1-25, 144, 504 and 1008 blocks.
   */
  get(k: number): number | undefined;
}
/**
 * Represents fee rate.
 *
 * This is an integer newtype representing fee rate in `sat/kwu`. It provides protection against mixing
 * up the types as well as basic formatting features.
 */
export class FeeRate {
  free(): void;
  constructor(sat_vb: bigint);
  /**
   * Returns raw fee rate.
   */
  readonly to_sat_per_kwu: bigint;
  /**
   * Converts to sat/vB rounding up.
   */
  readonly to_sat_per_vb_ceil: bigint;
  /**
   * Converts to sat/vB rounding down.
   */
  readonly to_sat_per_vb_floor: bigint;
}
/**
 * Data required to perform a spk-based blockchain client full scan.
 *
 * A client full scan iterates through all the scripts for the given keychains, fetching relevant
 * data until some stop gap number of scripts is found that have no data. This operation is
 * generally only used when importing or restoring previously used keychains in which the list of
 * used scripts is not known.
 */
export class FullScanRequest {
  private constructor();
  free(): void;
}
/**
 * A reference to a transaction output.
 */
export class LocalOutput {
  private constructor();
  free(): void;
  /**
   * Transaction output
   */
  readonly txout: TxOut;
  /**
   * The derivation index for the script pubkey in the wallet
   */
  readonly derivation_index: number;
  /**
   * Reference to a transaction output
   */
  readonly outpoint: OutPoint;
  /**
   * Type of keychain
   */
  readonly keychain: KeychainKind;
}
/**
 * A reference to a transaction output.
 */
export class OutPoint {
  free(): void;
  constructor(txid: Txid, vout: number);
  static from_string(outpoint_str: string): OutPoint;
  toString(): string;
  /**
   * The index of the referenced output in its transaction's vout.
   */
  readonly vout: number;
  /**
   * The referenced transaction's txid.
   */
  readonly txid: Txid;
}
/**
 * A Partially Signed Transaction.
 */
export class Psbt {
  private constructor();
  free(): void;
  extract_tx(): Transaction;
  extract_tx_with_fee_rate_limit(max_fee_rate: FeeRate): Transaction;
  fee(): Amount;
  fee_amount(): Amount | undefined;
  fee_rate(): FeeRate | undefined;
  /**
   * Serialize the PSBT to a string in base64 format
   */
  toString(): string;
  /**
   * Create a PSBT from a base64 string
   */
  static from_string(val: string): Psbt;
  /**
   * Serialize `Psbt` to JSON.
   */
  to_json(): string;
}
/**
 * A Transaction recipient
 */
export class Recipient {
  free(): void;
  constructor(address: Address, amount: Amount);
  readonly address: Address;
  readonly amount: Amount;
}
/**
 * An owned, growable script.
 *
 * `ScriptBuf` is the most common script type that has the ownership over the contents of the
 * script. It has a close relationship with its borrowed counterpart, [`Script`].
 */
export class ScriptBuf {
  private constructor();
  free(): void;
  toString(): string;
  as_bytes(): Uint8Array;
}
export class SentAndReceived {
  private constructor();
  free(): void;
  0: Amount;
  1: Amount;
}
export class SpkIndexed {
  private constructor();
  free(): void;
  0: KeychainKind;
  1: number;
}
/**
 * Data required to perform a spk-based blockchain client sync.
 *
 * A client sync fetches relevant chain data for a known list of scripts, transaction ids and
 * outpoints.
 */
export class SyncRequest {
  private constructor();
  free(): void;
}
/**
 * Bitcoin transaction.
 *
 * An authenticated movement of coins.
 */
export class Transaction {
  private constructor();
  free(): void;
  /**
   * Computes the [`Txid`].
   *
   * Hashes the transaction **excluding** the segwit data (i.e. the marker, flag bytes, and the
   * witness fields themselves). For non-segwit transactions which do not have any segwit data,
   * this will be equal to [`Transaction::compute_wtxid()`].
   */
  compute_txid(): Txid;
  /**
   * Returns the input at `input_index` if it exists.
   */
  tx_in(input_index: number): TxIn;
  /**
   * Returns the output at `output_index` if it exists.
   */
  tx_out(output_index: number): TxOut;
  clone(): Transaction;
  /**
   * Returns the base transaction size.
   *
   * > Base transaction size is the size of the transaction serialised with the witness data stripped.
   */
  readonly base_size: number;
  /**
   * Returns the total transaction size.
   *
   * > Total transaction size is the transaction size in bytes serialized as described in BIP144,
   * > including base data and witness data.
   */
  readonly total_size: number;
  /**
   * Returns the "virtual size" (vsize) of this transaction.
   *
   * Will be `ceil(weight / 4.0)`. Note this implements the virtual size as per [`BIP141`], which
   * is different to what is implemented in Bitcoin Core. The computation should be the same for
   * any remotely sane transaction, and a standardness-rule-correct version is available in the
   * [`policy`] module.
   *
   * > Virtual transaction size is defined as Transaction weight / 4 (rounded up to the next integer).
   */
  readonly vsize: number;
  /**
   * List of transaction inputs.
   */
  readonly input: TxIn[];
  /**
   * List of transaction outputs.
   */
  readonly output: TxOut[];
  /**
   * Checks if this is a coinbase transaction.
   *
   * The first transaction in the block distributes the mining reward and is called the coinbase
   * transaction. It is impossible to check if the transaction is first in the block, so this
   * function checks the structure of the transaction instead - the previous output must be
   * all-zeros (creates satoshis "out of thin air").
   */
  readonly is_coinbase: boolean;
  /**
   * Returns `true` if the transaction itself opted in to be BIP-125-replaceable (RBF).
   *
   * # Warning
   *
   * **Incorrectly relying on RBF may lead to monetary loss!**
   *
   * This **does not** cover the case where a transaction becomes replaceable due to ancestors
   * being RBF. Please note that transactions **may be replaced** even if they **do not** include
   * the RBF signal: <https://bitcoinops.org/en/newsletters/2022/10/19/#transaction-replacement-option>.
   */
  readonly is_explicitly_rbf: boolean;
  /**
   * Returns `true` if this transactions nLockTime is enabled ([BIP-65]).
   */
  readonly is_lock_time_enabled: boolean;
}
/**
 * A transaction builder.
 *
 * A `TxBuilder` is created by calling [`build_tx`] or [`build_fee_bump`] on a wallet. After
 * assigning it, you set options on it until finally calling [`finish`] to consume the builder and
 * generate the transaction.
 *
 * Each option setting method on `TxBuilder` takes and returns a new builder so you can chain calls
 */
export class TxBuilder {
  private constructor();
  free(): void;
  /**
   * Replace the recipients already added with a new list
   */
  set_recipients(recipients: Recipient[]): TxBuilder;
  /**
   * Add a recipient to the internal list
   */
  add_recipient(recipient: Recipient): TxBuilder;
  /**
   * Replace the internal list of unspendable utxos with a new list
   */
  unspendable(unspendable: OutPoint[]): TxBuilder;
  /**
   * Add a utxo to the internal list of unspendable utxos
   */
  add_unspendable(outpoint: OutPoint): TxBuilder;
  /**
   * Set a custom fee rate.
   *
   * This method sets the mining fee paid by the transaction as a rate on its size.
   * This means that the total fee paid is equal to `fee_rate` times the size
   * of the transaction. Default is 1 sat/vB in accordance with Bitcoin Core's default
   * relay policy.
   *
   * Note that this is really a minimum feerate -- it's possible to
   * overshoot it slightly since adding a change output to drain the remaining
   * excess might not be viable.
   */
  fee_rate(fee_rate: FeeRate): TxBuilder;
  /**
   * Spend all the available inputs. This respects filters like [`TxBuilder::unspendable`] and the change policy.
   */
  drain_wallet(): TxBuilder;
  /**
   * Sets the address to *drain* excess coins to.
   *
   * Usually, when there are excess coins they are sent to a change address generated by the
   * wallet. This option replaces the usual change address with an arbitrary `script_pubkey` of
   * your choosing. Just as with a change output, if the drain output is not needed (the excess
   * coins are too small) it will not be included in the resulting transaction. The only
   * difference is that it is valid to use `drain_to` without setting any ordinary recipients
   * with [`add_recipient`] (but it is perfectly fine to add recipients as well).
   *
   * If you choose not to set any recipients, you should provide the utxos that the
   * transaction should spend via [`add_utxos`].
   */
  drain_to(address: Address): TxBuilder;
  /**
   * Set whether or not the dust limit is checked.
   *
   * **Note**: by avoiding a dust limit check you may end up with a transaction that is non-standard.
   */
  allow_dust(allow_dust: boolean): TxBuilder;
  /**
   * Finish building the transaction.
   *
   * Returns a new [`Psbt`] per [`BIP174`].
   */
  finish(): Psbt;
}
/**
 * Bitcoin transaction input.
 *
 * It contains the location of the previous transaction's output,
 * that it spends and set of scripts that satisfy its spending
 * conditions.
 */
export class TxIn {
  private constructor();
  free(): void;
  /**
   * The reference to the previous output that is being used as an input.
   */
  readonly previous_output: OutPoint;
  /**
   * The script which pushes values on the stack which will cause
   * the referenced output's script to be accepted.
   */
  readonly script_sig: ScriptBuf;
  /**
   * Returns the base size of this input.
   *
   * Base size excludes the witness data.
   */
  readonly base_size: number;
  /**
   * Returns the total number of bytes that this input contributes to a transaction.
   *
   * Total size includes the witness data.
   */
  readonly total_size: number;
  /**
   * Returns true if this input enables the [`absolute::LockTime`] (aka `nLockTime`) of its
   * [`Transaction`].
   *
   * `nLockTime` is enabled if *any* input enables it. See [`Transaction::is_lock_time_enabled`]
   *  to check the overall state. If none of the inputs enables it, the lock time value is simply
   *  ignored. If this returns false and OP_CHECKLOCKTIMEVERIFY is used in the redeem script with
   *  this input then the script execution will fail [BIP-0065].
   */
  readonly enables_lock_time: boolean;
}
/**
 * Bitcoin transaction output.
 *
 * Defines new coins to be created as a result of the transaction,
 * along with spending conditions ("script", aka "output script"),
 * which an input spending it must satisfy.
 *
 * An output that is not yet spent by an input is called Unspent Transaction Output ("UTXO").
 */
export class TxOut {
  private constructor();
  free(): void;
  /**
   * The value of the output, in satoshis.
   */
  readonly value: Amount;
  /**
   * The script which must be satisfied for the output to be spent.
   */
  readonly script_pubkey: ScriptBuf;
  /**
   * Returns the total number of bytes that this output contributes to a transaction.
   *
   * There is no difference between base size vs total size for outputs.
   */
  readonly size: number;
}
/**
 * A bitcoin transaction hash/transaction ID.
 */
export class Txid {
  private constructor();
  free(): void;
  static from_string(txid_str: string): Txid;
  toString(): string;
}
/**
 * An update to [`Wallet`].
 */
export class Update {
  private constructor();
  free(): void;
}
export class Wallet {
  private constructor();
  free(): void;
  static create(network: Network, external_descriptor: string, internal_descriptor: string): Wallet;
  static load(changeset: ChangeSet, external_descriptor?: string | null, internal_descriptor?: string | null): Wallet;
  start_full_scan(): FullScanRequest;
  start_sync_with_revealed_spks(): SyncRequest;
  apply_update(update: Update): void;
  apply_update_at(update: Update, seen_at: bigint): void;
  next_unused_address(keychain: KeychainKind): AddressInfo;
  peek_address(keychain: KeychainKind, index: number): AddressInfo;
  reveal_next_address(keychain: KeychainKind): AddressInfo;
  reveal_addresses_to(keychain: KeychainKind, index: number): AddressInfo[];
  list_unused_addresses(keychain: KeychainKind): AddressInfo[];
  list_unspent(): LocalOutput[];
  list_output(): LocalOutput[];
  get_utxo(op: OutPoint): LocalOutput | undefined;
  transactions(): WalletTx[];
  get_tx(txid: Txid): WalletTx | undefined;
  take_staged(): ChangeSet | undefined;
  public_descriptor(keychain: KeychainKind): string;
  sign(psbt: Psbt): boolean;
  derivation_index(keychain: KeychainKind): number | undefined;
  build_tx(): TxBuilder;
  calculate_fee(tx: Transaction): Amount;
  calculate_fee_rate(tx: Transaction): FeeRate;
  sent_and_received(tx: Transaction): SentAndReceived;
  is_mine(script: ScriptBuf): boolean;
  derivation_of_spk(spk: ScriptBuf): SpkIndexed | undefined;
  readonly network: Network;
  readonly balance: Balance;
  readonly latest_checkpoint: CheckPoint;
}
/**
 * A Transaction managed by a `Wallet`.
 */
export class WalletTx {
  private constructor();
  free(): void;
  /**
   * Txid of the transaction.
   */
  readonly txid: Txid;
  /**
   * A partial or full representation of the transaction.
   */
  readonly tx: Transaction;
  /**
   * The blocks that the transaction is "anchored" in.
   */
  readonly anchors: ConfirmationBlockTime[];
  /**
   * The last-seen unix timestamp of the transaction as unconfirmed.
   */
  readonly last_seen_unconfirmed: bigint | undefined;
  /**
   * How the transaction is observed in the canonical chain (confirmed or unconfirmed).
   */
  readonly chain_position: ChainPosition;
}
